#!/bin/bash
# vim:ft=sh
# My functions
# Create hard link ~/.fun when running ~/.ash/a.sh -L
# and ~/.fun will be sourced in ~/.bash_profile
# Export all these funcions and set $fun_exported at the end of this file.

[ "$fun_exported" ] && return # since these functions have been exported, we don't need to soure this file anymore

# use some useless dconf keys to store info is a good idea.

# functions names will be overriden by aliases, this is so sad
# Causes syntax error if the word is already a alias
# So remove all aliases
unalias -a

set -a

b(){
    # Restore my key sequences if have any argument
    [ $1 ] && { bind -f ~/.inputrc; return; }

    # Otherwise, clear custom key sequences
    local i
    for i in $(bind -S | awk '{print $1}')
    do
        if [ ${#i} -gt 1 ]; then
            if [ $i = '\"' ]; then
                bind '"\"":self-insert'
            else
                bind -r "$i"
            fi
        else
            bind "$i":self-insert
        fi
    done
}

c(){
    cat "$@"
}

d(){
    cd "$@"
}

D(){
    s -t vps 5 ssh $vps -D7777
    s -X other
}

e(){
    echo "$@"
}

f(){
    if [ "$1" ]; then
        (feh -. "$@" &)
    fi
}

g(){
    local comment i opt
    case $1 in
        "")
            git status 2> /dev/null
            [ "$?" -eq 128 ] && echo -e $red${bold}Not a git repo $end && for i in $allrepos; do echo -e "${yellow}${bold}Checking ${italic}$i${end}"; git -C $i st; echo; done
            ;;
        d)
            [ "$?" -eq 128 ] && opt="-C $repoa"
            shift
            git $opt diff "$@"
            ;;
        c)
            [ "$?" -eq 128 ] && opt="-C $repoa"
            git $opt add -A
            shift
            comment=${*:-nth}
            git $opt commit -m "$comment"
            read -p "press any key in 5 sec to git push..." -n 1 -t5 i
            echo
            [ -n "$i" ] && echo -e "\nstarting push..." && git $opt push
            ;;
        *)
            git "$@"
            ;;
    esac
}

if [ "$ID" = FreeBSD ]; then
    ll(){
        command ls -l -G "$@"
    }
    # Put l.() { ...; } in one line to avoid vim wrong syntax indentation
    l.(){ command ls -Gd .* "$@"; }
    l(){
        command ls -G "$@"
    }
    ls(){
        # sudo command ls -G "$@"
        # sudo $(which ls) -G "$@"
        sudo ls -G "$@"
    }
else
    L(){
        command ls -Z "$@"
    }
    ll(){
        command ls -l --color=auto "$@"
    }
    LL(){
        command ls -lZ "$@"
    }
    l.(){ command ls -d .* --color=auto "$@"; }
    l(){
        command ls --color=auto "$@"
    }
    ls(){
        # sudo command ls --color=auto "$@"
        # sudo $(which ls) --color=auto "$@"
        sudo ls --color=auto "$@"
    }
fi

m(){
    [ $1 ] && { man $@; :; } || man bash
}

p(){
    [ $1 ] || { ping 8.8.8.8 && return; }
    # If not only contain numbers and ., take it as a domain
    [[ $1 =~ ^[0-9.]+$ ]] || { ping $1 && return; }

    local c ip
    # https://stackoverflow.com/a/21336679/7714132
    ip=$(ip route get 8.8.8.8 | awk -F'src ' 'NR==1 {split($2,a," ");print a[1]}')
    c=$(awk -F'.' '{print NF}' <<< "$1")
    case "$c" in
        1)
            ping $(cut -d'.' -f1-3 <<< $ip)."$1"
            ;;
        2)
            ping $(cut -d'.' -f1-2 <<< $ip)."$1"
            ;;
        3)
            ping 10."$1"
            ;;
        4)
            ping "$1"
            ;;
    esac
}

s(){
    local arg TERM
    #TERM=screen
    # we only use default command key (^Aa) in ssh
    [ "$SSH_TTY" ] ||  arg='-e ^Ss'

    # if we are in the matrix
    if [ "${STY#*.}" = "$screen" ];then
        screen "$@"
    else
        screen $arg -d -R -S $screen #-T $TERM
    fi
}

v(){
    if [ "$1" ];then
        command vim "$@"
    else
        # $vim_default_file defined in .env
        #command vim $vim_default_file
        # $vim_default_session defined in .env
        command vim -S $vim_default_session
    fi
}

py(){
    python3 "$@"
}

wg(){
    sudo wg "$@"
}

sy(){
    case $1 in
        e)
            shift
            sudo systemctl enable --now "$@"
            ;;
        d)
            shift
            sudo systemctl disable --now "$@"
            ;;
        s)
            shift
            systemctl status "$@"
            ;;
        S)
            shift
            sudo systemctl stop "$@"
            ;;
        r)
            shift
            sudo systemctl restart "$@"
            ;;
        *)
            systemctl "$@"
            ;;

    esac
}

dockertag(){
    [ "$1" ] || return
    wget -q https://registry.hub.docker.com/v1/repositories/$1/tags -O -  | sed -e 's/[][]//g' -e 's/"//g' -e 's/ //g' | tr '}' '\n'  | awk -F: '{print $3}' | less
}

vim(){
    # sudo looks for external programs, not shell builtins, and not shell functions
    # sudo command vim "$@"
    # sudo $(which vim) "$@"
    sudo vim "$@"
}

play(){
    if [ "$1" ]; then
        mpv --really-quiet "$@" &
    else
        # if cmus is running
        # are we in matrix?
        # select cmus
        # not running
        # screen cmus

        # assign 'select' to a var just to void vim syntax check error. because 'select' is a bash builtin
        local c=select
        # assume we are in the matrix
        if pgrep cmus; then
            #screen -S $screen -X $c cmus
            cmus-remote -u
        else
            screen -T screen 8 cmus
            # don't need this anymore since we have setting 'resume'
            #sleep 0.5
            #cmus-remote -p
            # cmus always start with the first song although shuffle is on
            #cmus-remote -n
        fi
    fi
}

qr(){
    qrencode -t ansiutf8 "$@"
}

warmane(){
    local interface
    interface=$(ip link | grep -o 'enp0s2\w*')
    ip link show $interface > /dev/null || return

    gateway=$(ip r show default dev $interface | awk '{print $3}')

    # auth
    sudo ip route add 188.138.40.87 via $gateway dev $interface
    # Icecrown 8092
    sudo ip route add 51.91.106.148 via $gateway dev $interface
    # Blackrock 8095 & Lordaeron 8091
    sudo ip route add 51.178.64.97 via $gateway dev $interface
    # Frostmourne 8096
    sudo ip route add 51.178.64.87 via $gateway dev $interface
}

drupalnew(){
    [ -z "$1" ] && echo Please type directory name. && return

    local gitignore name locale user mail pass site_path
    name=$1
    user=z
    db_user=root
    db_pass=toor
    mail=z@alz.ee
    pass=111
    locale=zh-hans
    gitignore=~/w/gitignore/Drupal.gitignore
    site_path=web/sites/default

    composer cre drupal/recommended-project $name
    cd $name
    composer req drush/drush drupal/{token,ctools,pathauto,metatag,admin_toolbar,adminimal_theme}
    composer req --dev drupal/devel
    mkdir bin
    ln -s ../vendor/bin/drush bin/
    git init
    cp "$gitignore" .gitignore

    # gitignore="https://raw.githubusercontent.com/alzee/gitignore/main/Drupal.gitignore"
    # wget "$gitignore" -O .gitignore

    bin/drush si --locale $locale  --db-url mysql://$db_user:$db_pass@localhost:3306/$name \
        --site-mail $mail --account-name $user --account-mail $mail --account-pass $pass -y

    bin/drush pm:enable token ctools pathauto admin_toolbar metatag devel -y
    # bin/drush pm:enable language locale -y # no need since they will be enabled if not install as en
    bin/drush theme:enable adminimal_theme

    # Setup development environment
    chmod 755 $site_path/
    chmod 644 $site_path/settings.php

    cp web/sites/example.settings.local.php $site_path/settings.local.php
    # Uncomment to load settings.local.php
    sed -i "/# if .*settings.local.php/,+2s/# //" $site_path/settings.php
    # Uncomment to disable render cache
    sed -i  "/^# \$settings.*render/s/# //" $site_path/settings.local.php
    # Uncomment to disable dynamic page cache
    sed -i  "/^# \$settings.*dynamic_page_cache/s/# //" $site_path/settings.local.php
    # Uncomment to disable **Internal page** cache
    sed -i  "/^# \$settings.*\<page\>/s/# //" $site_path/settings.local.php
    # debug true
    cp $site_path/default.services.yml $site_path/services.yml
    sed -i "/debug: false/s/false/true/" $site_path/services.yml

    chmod 555 $site_path/
    chmod 444 $site_path/{settings.php,settings.local.php,services.yml}

    # Custom config
    bin/drush cset metatag.metatag_defaults.front tags.title '[site:name]' -y
    bin/drush cset system.theme admin adminimal_theme -y
    bin/drush cset system.date country.default CN -y
    bin/drush cset system.date first_day 1 -y
    # bin/drush cset adminimal_theme.settings disable_google_fonts 1

    # TODO
    # menu settings can't export/import

    # Export config
    bin/drush cex -y
}

z(){
    local p=/.wine/drive_c/Program\ Files/Plants\ vs\ Zombies/PlantsVsZombies.exe
    wine ~/.wine/drive_c/Program\ Files/Plants\ vs\ Zombies/PlantsVsZombies.exe -changedir &> /dev/null &
}

mouse_speed_by_ctm(){
    # xinput set-prop 8 156 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000
    # id may change, use name instead
    local x y z
    if is_num $1 && [ "$mouse" -a "$ctm" ]; then
        x=$1 y=$1 z=$1
        xinput set-prop "$mouse" "$ctm" $x, 0, 0, 0, $y, 0, 0, 0, $z
    fi
}

enable_console(){
    sudo systemctl enable serial-getty@ttyS0.service
    sudo systemctl start serial-getty@ttyS0.service
}

reset_mysql_root_pw(){
    local i
    sudo mysqld_safe --skip-grant-tables --skip-networking
}

php_mssql(){
    echo apt install pear
    echo pecl channel-update pecl.php.net
    echo pecl install pdo_sqlsrv
    echo apt install unixodbc{,-dev}
    echo Remember the fucking ln in /etc/php/...
    echo dpkg -i msodbcsql17.... where to find? the fucing microsoft.com
    echo See some libmsodbcsql-17.3.so.1.1 file not found shit?
    echo ldd /opt/microsoft/msodbcsql17/lib64/libmsodbcsql-17.3.so.1.1
    echo and you will see libcrypto.so.1.0.2 and libssl.so.1.0.2 not found
    echo Now install libssl1.0.2, can not find in repo? Directly download from packages.debian.org
    echo Okay, enjoy your fucking MSSQL with php.
}

troubleshooting(){
    say Selinux?
    say Any typo?
    say Is this config file including other config files?
    say Version?
}

acme(){
    # Iusse certs with acme.sh, using CloudFlare API and DNS alias mode
    local dom certdir acme cmd alias
    #local CF_Token CF_Account_ID CF_Zone_ID
    #export CF_Token=""
    #export CF_Account_ID=""
    #export CF_Zone_ID=""

    [ -z "$1" ] && return

    dom="$1"
    alias="jiei.xyz"
    acme=~/.acme.sh/acme.sh
    cmd="sudo service apache2 force-reload"
    certdir=${3:-~/cert}

    $acme --issue -d "$dom" -d '*.'"$dom" --dns dns_cf --challenge-alias $alias
    $acme --install-cert -d "$dom" --key-file $certdir/$dom.key --cert-file $certdir/$dom.cer --fullchain-file $certdir/$dom.fullchain.cer --reloadcmd "$cmd"

    #$acme --renew -d "$dom"
    #$acme --issue -d "$dom" -d '*.'"$dom" --dns --yes-I-know-dns-manual-mode-enough-go-ahead-please
    #$acme --renew -d "$dom" --yes-I-know-dns-manual-mode-enough-go-ahead-please
}

# print battery info
ba(){
    local f fd n s
    fd=$(cat /sys/class/power_supply/BAT1/charge_full_design)
    f=$(cat /sys/class/power_supply/BAT1/charge_full)
    n=$(cat /sys/class/power_supply/BAT1/charge_now)
    s=$(cat /sys/class/power_supply/BAT1/status)
    echo charge_full/charge_full_design
    echo $f/$fd=$(echo "scale=2;$f*100/$fd" | bc)%
    echo charge_now/charge_full
    echo $n/$f=$(echo "scale=2;$n*100/$f" | bc)%
    echo $s
}

is_num(){
    local i
}

is_float(){
    local i
}

is_int(){
    local i
    i="$1"

    #if [[ "$i" =~ ^[-+]?[0-9]+$ ]]; then
    #	return 0
    #else
    #	return 1
    #fi

    # this solution has integer limit
    # https://stackoverflow.com/a/19116862/7714132
    #if [ "$i" -eq "$i" ] 2> /dev/null; then
    #	return 0
    #else
    #	return 1
    #fi

    # https://stackoverflow.com/a/18620446/7714132
    case ${i#[-+]} in
        *[!0-9]* | '')
            return 1
            ;;
        *)
            return 0
            ;;
    esac
}

cleanup(){
    # should i add a cron for this?
    ### vim undo file
    local d=~/.vim/undo/
    find $d -mtime +15 -delete
    ### ~/.cache 
    ### /var/cache
    ### /var/log
}

cmdnotfound(){
    # if last command return 127 (not found), do something with it
    # TODO how to deal with HISTCONTROL ignored command which don't have history?
    local cmd r=$?	# r=$? must at the first line or we'll get return code of `local' builtin
    if [ "$r" -eq 127 ]; then
        cmd=$(HISTTIMEFORMAT= history 1 | sed 's/^ *[0-9]\+ *//')
        # who_is her? OR Who is her?
        tts "${cmd//_/ }"
    fi
}

totp(){
    if [ -z $1 ]; then
        cat <<HERE
Usage:
totp <keyname>          Generate a totp code
totp -d                 Decrypt keys in ~/.sec/totp-key/ and output to ~/totp-key/
totp -e <recipient>     Encrypt keys in ~/totp-key/ and output to ~/.sec/totp-key/
HERE

return
    fi

    local key keyfile sec dir decrypt_dir
    dir=~/.sec/totp-key
    decrypt_dir=~/totp-key

    if [ $1 = -d ]; then
        [ -d "$dir" ] || { echo directory "$dir" not exists; return; }
        # https://superuser.com/a/352367/886777
        # No need -A here since `for i in *` don't include dot files
        [ $(command ls "$dir" | wc -w) -eq 0 ] && { echo directory "$dir" is empty; return; }
        mkdir -p $decrypt_dir
        for i in $dir/*
        do
            gpg --yes -q -o $decrypt_dir/${i##*/} -d $i
        done
        return
    fi

    if [ $1 = -e ]; then
        [ -d "$decrypt_dir" ] || { echo decrypt directory "$decrypt_dir" not exists; return; }
        [ $(command ls "$decrypt_dir" | wc -w) -eq 0 ] && { echo directory "$decrypt_dir" is empty; return; }
        mkdir -p $dir
        [ "$2" ] || { echo "Usage: totp -e <recipient>"; return; }
        for i in $decrypt_dir/*
        do
            gpg --yes --trust-model always -a -r "$2" -o $dir/${i##*/} -e $i
        done
        return
    fi

    keyfile=$(echo $dir/$1*)
    keyfile=${keyfile%% *}	# only first one
    if [ -f $keyfile ];then
        key=$(gpg -dq $keyfile)
        [ "$key" ] || return
        echo $keyfile
        oathtool --totp -b "$key"
        sec=$(date +%S)
        sec=${sec#0}
        [ $sec -ge 30 ] && let sec=60-sec || let sec=30-sec
        echo $sec seconds left
    else
        echo $keyfile no found
    fi
}

bt(){
    if ! pidof transmission-daemon; then
        transmission-daemon
        sleep 0.5	# why
    fi
    if [ "$1" ];then
        transmission-remote "$@"
    else
        transmission-remote -l
    fi
}

irc(){
    # if irssi is running
    # are we in matrix?
    # select irssi
    # not running
    # screen irssi

    # assign 'select' to a var just to void vim syntax check error. because 'select' is a bash builtin
    local c=select
    # assume we are in the matrix
    if pgrep irssi; then
        screen -S $screen -X $c irssi
    else
        screen -t irssi -T screen 9 irssi
    fi
}

mip(){
    local ip
    ip=$(curl -s 'https://api.ipify.org')
    echo $ip
}

vpaste(){
    uri="http://vpaste.net/"
    if [ -f "$1" ]; then
        out=`curl -s -F "text=<$1" "$uri?$2"`
    else
        out=`curl -s -F 'text=<-' "$uri?$1"`
    fi
    echo "$out"
    if [ -x "`which xclip 2>/dev/null`" -a "$DISPLAY" ]; then
        echo -n "$out" | xclip -i -selection primary
        echo -n "$out" | xclip -i -selection clipboard
    fi
}

am(){
    local start_target httpd web_server mariadb stop_target fpm i
    mariadb=mariadb
    httpd=httpd
    stop_target=nginx
    case $ID in
        debian)
            pushd /etc/apache2/conf-enabled/
            fpm=$(echo php*)
            popd
            fpm=${fpm//.conf/}
            httpd=apache2
            mariadb=mysql
            ;;
        fedora)
            fpm=php-fpm
            ;;
    esac

    web_server=$httpd

    if [ "$1" = -n ]; then
        web_server=nginx
        stop_target=$httpd
    fi

    # WSL do have systemctl but not working, so test with a sub-command rather than `which systemctl`
    if systemctl list-jobs &> /dev/null; then
        sudo systemctl stop $stop_target
        sudo systemctl restart $web_server $mariadb $fpm
    else
        sudo service $stop_target stop
        sudo service $web_server stop
        sudo service $mariadb stop
        sudo service $web_server start
        sudo service $mariadb start
        for i in $fpm
        do
            sudo service $i stop
            sudo service $i start
        done
    fi
}

smb(){
    local sever share mountpoint user

    # -s to setup a samba service
    # if not installed
    sudo dnf install samba
    sudo smbpasswd -a $user
    # edit /etc/samba/smb.cnf
    sudo systemctl restart smb
    # firewalld
    # selinux

    # client side
    sudo mount.cifs //$server/$share $mountpoint -o guest,user=guest,uid=1000

    # if permission denied, should be selinux
}

nfs(){
    # server side
    # sudo systemctl restart nfs
    # edit /etc/exports
    # man exports

    # exportfs -ra

    # client side
    # mount server:share_dir somedir
    :
}

# assign array a to array b
assign_array(){
    local a=$1
    unset b
    # declare array b as associaitve if a is
    declare -A $a 2> /dev/null && declare -A $b

    for i in $(eval echo \${!$a[@]})
    do
        eval $b[$i]=\${$a[$i]}
    done
}

# get key of the value in an array
getkey(){
    # $1 value, $2 array
    local i v=$1 a=$2
    # assign_array $2 $a
    for i in $(eval echo \${!$a[@]})
    do
        #echo $i
        eval [ "$v" == \${$a[$i]} ] && echo $i && return 0
    done
    return 1
}

self_sign_cert(){
    [ -z $1 ] && echo the key name, asshole! && return
    local i=$1
    local key=$i.key
    local pem=$i.pem
    local csr=$i.csr
    local crt=$i.crt

    #openssl req -x509 -new -newkey rsa:4096 -sha256 -days 1000 -nodes -out freenode.pem -keyout freenode.pem
    # or
    #openssl req -nodes -newkey rsa:2048 -keyout user.pem -x509 -days 3650 -out user.pem -subj "/CN=YourNickname"
    # or
    # generate private key
    openssl genrsa -des3 -out $pem 1024
    # generate CSR
    openssl req -new -key $pem -out $csr
    # remove password
    openssl rsa -in $pem -out $key
    # issue a certificate signed with $key
    openssl x509 -req -days 365 -in $csr -signkey $key -out $crt
}

say(){
    [ -z "$1" ] && echo "say what?" && return
    set $@ # so we can use quotes
    echo -en ${red}${bold}
    while :; do
        echo -n $1
        shift
        [ -z $1 ] && echo && break || echo -n " "
        local r=`date +%N`
        r=${r##*0}
        local r=${r:0:1} # a 1~9 random number
        sleep 0.$r
    done
    echo -en ${end}
}

countdown(){
    local i j from to interval
    from=${1:-100}
    echo -en ${red}${bold}
    for i in `seq -w 0 $from | sort -rn`; do
        for j in `seq ${#i}`; do
            echo -ne \\b
        done
        echo -n $i
        [ $i -gt 0 ] && sleep 1
    done
    echo -e ${end}
}

grep(){
    command grep --color=auto "$@"
}

githooks(){
    # Run in root of working tree
    # then hooks in .githooks will be tracked and can be triggered whether or not "during a push",
    # as long as it's not a bare repo.
    if [ -d .git ]; then
        mkdir -p .githooks
        ln -sf ../.githooks/ .git/
    fi
}

lhand(){
    local lhanded
    [ "$mouse" ] && lhanded=$(xinput list-props "$mouse" | grep  "Left Handed Enabled (" | cut -f3)
    [ "$touchpad" ] && lhanded=$(xinput list-props "$touchpad" | grep  "Left Handed Enabled (" | cut -f3)

    if [ "$lhanded" -eq 0 ]; then
        [ "$mouse" ] && xinput set-prop "$mouse" 'libinput Left Handed Enabled' 1
        [ "$touchpad" ] && xinput set-prop "$touchpad" 'libinput Left Handed Enabled' 1
    else
        [ "$mouse" ] && xinput set-prop "$mouse" 'libinput Left Handed Enabled' 0
        [ "$touchpad" ] && xinput set-prop "$touchpad" 'libinput Left Handed Enabled' 0
    fi

    # use the bitwise XOR-equal operator to flip between 0 and 1
    # https://unix.stackexchange.com/a/364489/274163
    echo $((lhanded ^ 1))
}

idlast(){
    #local id=${1::17}
    local id=$1
    [ ${#id} -lt 17 ] && echo 17 numbers, assohole! && return 69
    local factor=(7 9 10 5 8 4 2 1 6 3 7 9 10 5 8 4 2)
    local last=(1 0 X 9 8 7 6 5 4 3 2)

    local i sum=0
    for i in `seq 0 16`
    do
        let sum+=$((${id:$i:1} * ${factor[$i]}))
    done

    echo ${last[$(($sum%11))]}
}

ascii_of(){
    if [ "$1" == -c ];then
        [ "$2" -lt 256 ] || return 1
        printf "\\$(printf '%03o' "$2")"
        return 0
    fi
    printf '%d\n' "'$1"
}

expecting_SSH2_MSG_KEX_ECDH_REPLY(){
    local if
    if=$1
    # https://serverfault.com/a/670081
    sudo ip li set mtu 1200 dev $if
}

are_u_sure(){
    read -n1 -p "Are you sure to exit? [y/N] "
    [ "$REPLY" != y ] && { echo; history -a; bash; }
}
#trap are_u_sure EXIT

# reload ~/.{env,fun}
rl(){
    fun_exported=
    env_exported=
    . ~/.env
    . ~/.fun
}

fun_exported=my_length_is_nonzero

[ -f ~/.fun.local ] && . ~/.fun.local

set +a
