#!/bin/bash
# vim:ft=sh
# My functions
# Create hard link ~/.fun when running ~/.ash/a.sh -L
# and ~/.fun will be sourced in ~/.bash_profile
# Export all these funcions and set $FUN_EXPORTED at the end of this file.

# Fedora /etc/bashrc will source /etc/profile.d/*.sh
# and some of them will set aliases
# functions names will be overriden by aliases, this is so sad
# and it causes syntax error if the word is already a alias when define a fun
# So remove all aliases
unalias -a

[ "$FUN_EXPORTED" ] && return # since these functions have been exported, we don't need to soure this file anymore

# use some useless dconf keys to store info is a good idea.

set -a

activate(){
    [ -f .venv/bin/activate ] && . .venv/bin/activate
}

b(){
    # Restore my key sequences if have any argument
    [ $1 ] && { bind -f ~/.inputrc; return; }

    # Otherwise, clear custom key sequences
    local i
    for i in $(bind -S | awk '{print $1}')
    do
        if [ ${#i} -gt 1 ]; then
            if [ $i = '\"' ]; then
                bind '"\"":self-insert'
            else
                bind -r "$i"
            fi
        else
            bind "$i":self-insert
        fi
    done
}

c(){
    cargo "$@"
}

d(){
    cd "$@"
}

e(){
    echo "$@"
}

f(){
    if [ "$1" ]; then
        (feh -. "$@" &)
    fi
}

if [ "$ID" = FreeBSD ]; then
    ll(){
        command ls -l -G "$@"
    }
    # Put l.() { ...; } in one line to avoid vim wrong syntax indentation
    l.(){ command ls -Gd .* "$@"; }
    l(){
        command ls -G "$@"
    }
    ls(){
        # sudo command ls -G "$@"
        # sudo $(which ls) -G "$@"
        sudo ls -G "$@"
    }
else
    L(){
        command ls -Z "$@"
    }
    ll(){
        command ls -l --color=auto "$@"
    }
    LL(){
        command ls -lZ "$@"
    }
    l.(){ command ls -d .* --color=auto "$@"; }
    l(){
        command ls --color=auto "$@"
    }
    ls(){
        # sudo command ls --color=auto "$@"
        # sudo $(which ls) --color=auto "$@"
        sudo ls --color=auto "$@"
    }
fi

m(){
    [ $1 ] && { man $@; :; } || man bash
}

py(){
    python3 "$@"
}

wg(){
    sudo wg "$@"
}

dockertag(){
    [ "$1" ] || return
    wget -q https://registry.hub.docker.com/v1/repositories/$1/tags -O -  | sed -e 's/[][]//g' -e 's/"//g' -e 's/ //g' | tr '}' '\n'  | awk -F: '{print $3}' | less
}

vim(){
    # sudo looks for external programs, not shell builtins, and not shell functions
    # sudo command vim "$@"
    # sudo $(which vim) "$@"
    sudo vim "$@"
}

qr(){
    qrencode -t ansiutf8 "$@"
}

pvz(){
    local p=/.wine/drive_c/Program\ Files/Plants\ vs\ Zombies/PlantsVsZombies.exe
    wine ~/.wine/drive_c/Program\ Files/Plants\ vs\ Zombies/PlantsVsZombies.exe -changedir &> /dev/null &
}

cmdnotfound(){
    # if last command return 127 (not found), do something with it
    # TODO how to deal with HISTCONTROL ignored command which don't have history?
    local cmd r=$?	# r=$? must at the first line or we'll get return code of `local' builtin
    if [ "$r" -eq 127 ]; then
        cmd=$(HISTTIMEFORMAT= history 1 | sed 's/^ *[0-9]\+ *//')
        # who_is her? OR Who is her?
        tts "${cmd//_/ }"
    fi
}

grep(){
    command grep --color=auto "$@"
}

are_u_sure(){
    read -n1 -p "Are you sure to exit? [y/N] "
    [ "$REPLY" != y ] && { echo; history -a; bash; }
}
#trap are_u_sure EXIT

# reload ~/.{env,fun}
rl(){
    FUN_EXPORTED=
    ENV_EXPORTED=
    . ~/.env
    . ~/.fun
}

let FUN_EXPORTED++

[ -f ~/.fun.local ] && . ~/.fun.local

set +a
