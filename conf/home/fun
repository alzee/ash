#!/bin/bash
# vim:ft=sh
# My functions
# Create hard link ~/.fun when running ~/.ash/a.sh -H
# and ~/.fun will be sourced in ~/.bash_profile
# Export all these funcions and set $fun_exported at the end of this file.

[ "$fun_exported" ] && return # since these functions have been exported, we don't need to soure this file anymore

# use some useless dconf keys to store info is a good idea.

# functions names will be overriden by aliases, this is so sad
# Causes syntax error if the word is already a alias
# So remove all aliases
unalias -a

set -a

warmane(){
    local interface
    interface=$(ip link | grep -o 'enp0s2\w*')
    ip link show $interface > /dev/null || return

    gateway=$(ip r show default dev $interface | awk '{print $3}')

    # auth
    sudo ip route add 188.138.40.87 via $gateway dev $interface
    # Icecrown 8092
    sudo ip route add 51.91.106.148 via $gateway dev $interface
    # Blackrock 8095 & Lordaeron 8091
    sudo ip route add 51.178.64.97 via $gateway dev $interface
    # Frostmourne 8096
    sudo ip route add 51.178.64.87 via $gateway dev $interface
}

drupalnew(){
    [ -z "$1" ] && echo Please type directory name. && return

    local gitignore name locale user mail pass site_path
    name=$1
    user=z
    db_user=root
    db_pass=toor
    mail=z@alz.ee
    pass=111
    locale=zh-hans
    gitignore=~/w/gitignore/Drupal.gitignore
    site_path=web/sites/default

    composer cre drupal/recommended-project $name
    cd $name
    composer req drush/drush drupal/{token,ctools,pathauto,metatag,admin_toolbar,adminimal_theme}
    composer req --dev drupal/devel
    mkdir bin
    ln -s ../vendor/bin/drush bin/
    git init
    cp "$gitignore" .gitignore

    # gitignore="https://raw.githubusercontent.com/alzee/gitignore/main/Drupal.gitignore"
    # wget "$gitignore" -O .gitignore

    bin/drush si --locale $locale  --db-url mysql://$db_user:$db_pass@localhost:3306/$name \
        --site-mail $mail --account-name $user --account-mail $mail --account-pass $pass -y

    bin/drush pm:enable token ctools pathauto admin_toolbar metatag devel -y
    # bin/drush pm:enable language locale -y # no need since they will be enabled if not install as en
    bin/drush theme:enable adminimal_theme

    # Setup development environment
    chmod 755 $site_path/
    chmod 644 $site_path/settings.php

    cp web/sites/example.settings.local.php $site_path/settings.local.php
    # Uncomment to load settings.local.php
    sed -i "/# if .*settings.local.php/,+2s/# //" $site_path/settings.php
    # Uncomment to disable render cache
    sed -i  "/^# \$settings.*render/s/# //" $site_path/settings.local.php
    # Uncomment to disable dynamic page cache
    sed -i  "/^# \$settings.*dynamic_page_cache/s/# //" $site_path/settings.local.php
    # Uncomment to disable **Internal page** cache
    sed -i  "/^# \$settings.*\<page\>/s/# //" $site_path/settings.local.php
    # debug true
    cp $site_path/default.services.yml $site_path/services.yml
    sed -i "/debug: false/s/false/true/" $site_path/services.yml

    chmod 555 $site_path/
    chmod 444 $site_path/{settings.php,settings.local.php,services.yml}

    # Custom config
    bin/drush cset metatag.metatag_defaults.front tags.title '[site:name]' -y
    bin/drush cset system.theme admin adminimal_theme -y
    bin/drush cset system.date country.default CN -y
    bin/drush cset system.date first_day 1 -y
    # bin/drush cset adminimal_theme.settings disable_google_fonts 1

    # TODO
    # menu settings can't export/import

    # Export config
    bin/drush cex -y
}

z(){
    local p=/.wine/drive_c/Program\ Files/Plants\ vs\ Zombies/PlantsVsZombies.exe
    wine ~/.wine/drive_c/Program\ Files/Plants\ vs\ Zombies/PlantsVsZombies.exe -changedir &> /dev/null &
}

f(){
    if [ "$1" ]; then
        (feh -. "$@" &)
    fi
}

wgz(){
    local wg_if wg_ip wg_port wg_key wg_peer wg_allowdips wg_endpoint sec
    wg_if=wg0
    wg_ip=10.5.5.5/24
    wg_port=51820
    wg_peer=
    wg_allowedips=
    wg_endpoint=
    wg_key=
    sec=30

    ip link add $wg_if type wireguard
    ip addr add dev $wg_if $wg_ip
    ip link set $wg_if up

    wg set $wg_if private-key $wg_key
    wg set $wg_if listen-port $wg_port
    wg set $wg_if peer $wg_peer allowed-ips $wg_allowedips endpoint $wg_endpoint persistent-keepalive $sec
}

mouse_speed_by_ctm(){
    # xinput set-prop 8 156 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000
    # id may change, use name instead
    local x y z
    if is_num $1 && [ "$mouse" -a "$ctm" ]; then
        x=$1 y=$1 z=$1
        xinput set-prop "$mouse" "$ctm" $x, 0, 0, 0, $y, 0, 0, 0, $z
    fi
}

enable_console(){
    sudo systemctl enable serial-getty@ttyS0.service
    sudo systemctl start serial-getty@ttyS0.service
}

reset_mysql_root_pw(){
    local i
    sudo mysqld_safe --skip-grant-tables --skip-networking
}

php_mssql(){
    echo apt install pear
    echo pecl channel-update pecl.php.net
    echo pecl install pdo_sqlsrv
    echo apt install unixodbc{,-dev}
    echo Remember the fucking ln in /etc/php/...
    echo dpkg -i msodbcsql17.... where to find? the fucing microsoft.com
    echo See some libmsodbcsql-17.3.so.1.1 file not found shit?
    echo ldd /opt/microsoft/msodbcsql17/lib64/libmsodbcsql-17.3.so.1.1
    echo and you will see libcrypto.so.1.0.2 and libssl.so.1.0.2 not found
    echo Now install libssl1.0.2, can not find in repo? Directly download from packages.debian.org
    echo Okay, enjoy your fucking MSSQL with php.
}

z_ping(){
    local c ip
    # get ip address
    ip=$(hostname -I)
    if [ "$ip" = 127.0.0.1 ]; then
        # https://stackoverflow.com/a/21336679/7714132
        ip=$(ip route get 8.8.8.8 | awk -F'src ' 'NR==1 {split($2,a," ");print a[1]}')
    fi
    c=$(awk -F'.' '{print NF-1}' <<< "$1")
    case "$c" in
        0)
            ping $(cut -d'.' -f1-3 <<< $ip)."$1"
            ;;
        1)
            ping $(cut -d'.' -f1-2 <<< $ip)."$1"
            ;;
        2)
            ;;
        3)
            ping "$1"
            ;;
    esac
}

e(){
    echo -e '\e[33;1m'$@'\e[m'
}

troubleshooting(){
    say Selinux?
    say Any typo?
    say Is this config file including other config files?
    say Version?
}

acme(){
    # Iusse certs with acme.sh, using CloudFlare API and DNS alias mode
    local dom certdir acme cmd alias
    #local CF_Token CF_Account_ID CF_Zone_ID
    #export CF_Token=""
    #export CF_Account_ID=""
    #export CF_Zone_ID=""

    [ -z "$1" ] && return

    dom="$1"
    alias="jiei.xyz"
    acme=~/.acme.sh/acme.sh
    cmd="sudo service apache2 force-reload"
    certdir=${3:-~/cert}

    $acme --issue -d "$dom" -d '*.'"$dom" --dns dns_cf --challenge-alias $alias
    $acme --install-cert -d "$dom" --key-file $certdir/$dom.key --cert-file $certdir/$dom.cer --fullchain-file $certdir/$dom.fullchain.cer --reloadcmd "$cmd"

    #$acme --renew -d "$dom"
    #$acme --issue -d "$dom" -d '*.'"$dom" --dns --yes-I-know-dns-manual-mode-enough-go-ahead-please
    #$acme --renew -d "$dom" --yes-I-know-dns-manual-mode-enough-go-ahead-please
}

# print battery info
ba(){
    local f fd n s
    fd=$(cat /sys/class/power_supply/BAT1/charge_full_design)
    f=$(cat /sys/class/power_supply/BAT1/charge_full)
    n=$(cat /sys/class/power_supply/BAT1/charge_now)
    s=$(cat /sys/class/power_supply/BAT1/status)
    echo charge_full/charge_full_design
    echo $f/$fd=$(echo "scale=2;$f*100/$fd" | bc)%
    echo charge_now/charge_full
    echo $n/$f=$(echo "scale=2;$n*100/$f" | bc)%
    echo $s
}

is_num(){
    local i
}

is_float(){
    local i
}

is_int(){
    local i
    i="$1"

    #if [[ "$i" =~ ^[-+]?[0-9]+$ ]]; then
    #	return 0
    #else
    #	return 1
    #fi

    # this solution has integer limit
    # https://stackoverflow.com/a/19116862/7714132
    #if [ "$i" -eq "$i" ] 2> /dev/null; then
    #	return 0
    #else
    #	return 1
    #fi

    # https://stackoverflow.com/a/18620446/7714132
    case ${i#[-+]} in
        *[!0-9]* | '')
            return 1
            ;;
        *)
            return 0
            ;;
    esac
}

# brightness
b(){
    local i j k
    k=$(cat /sys/class/backlight/intel_backlight/max_brightness)

    if [ -z "$1" ]; then
        # print brightness if no parameters
        j=$(cat /sys/class/backlight/intel_backlight/brightness)
        echo $j/$k
    else
        i=$1
        if is_int "$i"; then
            [ "$i" -eq 0 ] && echo do not set to 0, you idiot! && return
            [ "$i" -lt 0 ] && echo how can it be negative, you idiot! && return
            [ "$i" -gt "$k" ] && echo can not bigger then "$k" && return
            sudo sh -c "echo $i > /sys/class/backlight/intel_backlight/brightness"
        else
            echo give me an integer, idiot!
        fi
    fi
}

cleanup(){
    # should i add a cron for this?
    ### vim undo file
    local d=~/.vim/undo/
    find $d -mtime +15 -delete
    ### ~/.cache 
    ### /var/cache
    ### /var/log
}

cmdnotfound(){
    # if last command return 127 (not found), do something with it
    # TODO how to deal with HISTCONTROL ignored command which don't have history?
    local cmd r=$?	# r=$? must at the first line or we'll get return code of `local' builtin
    if [ "$r" -eq 127 ]; then
        cmd=$(HISTTIMEFORMAT= history 1 | sed 's/^ *[0-9]\+ *//')
        # who_is her? OR Who is her?
        tts "${cmd//_/ }"
    fi
}

D(){
    s -t vps 5 ssh $vps -D7777
    s -X other
}

totp(){
    local key keyfile sec secdir
    secdir=~/.sec
    keyfile=$(echo $secdir/totp-key/$1*)

    keyfile=${keyfile%% *}	# only first one
    if [ -f $keyfile ];then
        key=$(gpg -dq $keyfile)
        [ "$key" ] || return
        echo $keyfile
        oathtool --totp -b "$key"
        sec=$(date +%S)
        sec=${sec#0}
        [ $sec -ge 30 ] && let sec=60-sec || let sec=30-sec
        echo $sec seconds left
    else
        echo $keyfile no found
    fi
}

t(){
    if ! pidof transmission-daemon; then
        transmission-daemon
        sleep 0.5	# why
    fi
    if [ "$1" ];then
        transmission-remote "$@"
    else
        transmission-remote -l
    fi
}

i(){
    # if irssi is running
    # are we in matrix?
    # select irssi
    # not running
    # screen irssi

    # assign 'select' to a var just to void vim syntax check error. because 'select' is a bash builtin
    local c=select
    # assume we are in the matrix
    if pgrep irssi; then
        screen -S $screen -X $c irssi
    else
        screen -T screen 9 irssi
    fi
}

c(){
    # if cmus is running
    # are we in matrix?
    # select cmus
    # not running
    # screen cmus

    # assign 'select' to a var just to void vim syntax check error. because 'select' is a bash builtin
    local c=select
    # assume we are in the matrix
    if pgrep cmus; then
        #screen -S $screen -X $c cmus
        cmus-remote -u
    else
        screen -T screen 8 cmus
        # don't need this anymore since we have setting 'resume'
        #sleep 0.5
        #cmus-remote -p
        # cmus always start with the first song although shuffle is on
        #cmus-remote -n
    fi
}

s(){
    local arg TERM
    #TERM=screen
    # we only use default command key (^Aa) in ssh
    [ "$SSH_TTY" ] ||  arg='-e ^Ss'

    # if we are in the matrix
    if [ "${STY#*.}" = "$screen" ];then
        screen "$@"
    else
        screen $arg -d -R -S $screen #-T $TERM
    fi
}

mip(){
    local ip
    ip=$(curl -s 'https://api.ipify.org')
    echo $ip
}

vpaste(){
    uri="http://vpaste.net/"
    if [ -f "$1" ]; then
        out=`curl -s -F "text=<$1" "$uri?$2"`
    else
        out=`curl -s -F 'text=<-' "$uri?$1"`
    fi
    echo "$out"
    if [ -x "`which xclip 2>/dev/null`" -a "$DISPLAY" ]; then
        echo -n "$out" | xclip -i -selection primary
        echo -n "$out" | xclip -i -selection clipboard
    fi
}

am(){
    local start_target httpd web_server mariadb stop_target fpm i
    mariadb=mariadb
    httpd=httpd
    stop_target=nginx
    case $ID in
        debian)
            pushd /etc/apache2/conf-enabled/
            fpm=$(echo php*)
            popd
            fpm=${fpm//.conf/}
            httpd=apache2
            mariadb=mysql
            ;;
        fedora)
            fpm=php-fpm
            ;;
    esac

    web_server=$httpd

    if [ "$1" = -n ]; then
        web_server=nginx
        stop_target=$httpd
    fi

    # WSL do have systemctl but not working, so test with a sub-command rather than `which systemctl`
    if systemctl list-jobs &> /dev/null; then
        sudo systemctl stop $stop_target
        sudo systemctl restart $web_server $mariadb $fpm
    else
        sudo service $stop_target stop
        sudo service $web_server stop
        sudo service $mariadb stop
        sudo service $web_server start
        sudo service $mariadb start
        for i in $fpm
        do
            sudo service $i stop
            sudo service $i start
        done
    fi
}

smb(){
    local sever share mountpoint user

    # -s to setup a samba service
    # if not installed
    sudo dnf install samba
    sudo smbpasswd -a $user
    # edit /etc/samba/smb.cnf
    sudo systemctl restart smb
    # firewalld
    # selinux

    # client side
    sudo mount.cifs //$server/$share $mountpoint -o guest,user=guest,uid=1000

    # if permission denied, should be selinux
}

nfs(){
    # server side
    # sudo systemctl restart nfs
    # edit /etc/exports
    # man exports

    # exportfs -ra

    # client side
    # mount server:share_dir somedir
    :
}

# assign array a to array b
assign_array(){
    local a=$1
    unset b
    # declare array b as associaitve if a is
    declare -A $a 2> /dev/null && declare -A $b

    for i in $(eval echo \${!$a[@]})
    do
        eval $b[$i]=\${$a[$i]}
    done
}

# get key of the value in an array
getkey(){
    # $1 value, $2 array
    local i v=$1 a=$2
    # assign_array $2 $a
    for i in $(eval echo \${!$a[@]})
    do
        #echo $i
        eval [ "$v" == \${$a[$i]} ] && echo $i && return 0
    done
    return 1
}

self_sign_cert(){
    [ -z $1 ] && echo the key name, asshole! && return
    local i=$1
    local key=$i.key
    local pem=$i.pem
    local csr=$i.csr
    local crt=$i.crt

    #openssl req -x509 -new -newkey rsa:4096 -sha256 -days 1000 -nodes -out freenode.pem -keyout freenode.pem
    # or
    #openssl req -nodes -newkey rsa:2048 -keyout user.pem -x509 -days 3650 -out user.pem -subj "/CN=YourNickname"
    # or
    # generate private key
    openssl genrsa -des3 -out $pem 1024
    # generate CSR
    openssl req -new -key $pem -out $csr
    # remove password
    openssl rsa -in $pem -out $key
    # issue a certificate signed with $key
    openssl x509 -req -days 365 -in $csr -signkey $key -out $crt
}

say(){
    [ -z "$1" ] && echo "say what?" && return
    set $@ # so we can use quotes
    echo -en ${red}${bold}
    while :; do
        echo -n $1
        shift
        [ -z $1 ] && echo && break || echo -n " "
        local r=`date +%N`
        r=${r##*0}
        local r=${r:0:1} # a 1~9 random number
        sleep 0.$r
    done
    echo -en ${end}
}

countdown(){
    local i j from to interval
    from=${1:-100}
    echo -en ${red}${bold}
    for i in `seq -w 0 $from | sort -rn`; do
        for j in `seq ${#i}`; do
            echo -ne \\b
        done
        echo -n $i
        [ $i -gt 0 ] && sleep 1
    done
    echo -e ${end}
}

grep(){
    command grep --color=auto "$@"
}

# git
g(){
    local comment i opt
    case $1 in
        "")
            git status 2> /dev/null
            [ "$?" -eq 128 ] && echo -e $red${bold}Not a git repo $end && for i in $allrepos; do echo -e "${yellow}${bold}Checking ${italic}$i${end}"; git -C $i st; echo; done
            ;;
        d)
            [ "$?" -eq 128 ] && opt="-C $repoa"
            shift
            git $opt diff "$@"
            ;;
        c)
            [ "$?" -eq 128 ] && opt="-C $repoa"
            git $opt add -A
            shift
            comment=${*:-nth}
            git $opt commit -m "$comment"
            read -p "press any key in 5 sec to git push..." -n 1 -t5 i
            echo
            [ -n "$i" ] && echo -e "\nstarting push..." && git $opt push
            ;;
        *)
            git "$@"
            ;;
    esac
}

githooks(){
    # Run in root of working tree
    # then hooks in .githooks will be tracked and can be triggered whether or not "during a push",
    # as long as it's not a bare repo.
    if [ -d .git ]; then
        mkdir -p .githooks
        ln -sf ../.githooks/ .git/
    fi
}

# switch mouse left-right-hand
_lhand(){
    # TODO use dconf instead of gsettings
    # xinput xmodmap cause error if we are not in x
    # we are in DE or WM?
    # if we are in gnome, don't do the rest
    local gget='gsettings get'
    local lhand='org.gnome.desktop.peripherals.mouse left-handed'
    local gset='gsettings set'
    local batcent='org.gnome.desktop.interface show-battery-percentage' 
    local touchpad=$(xinput | grep -i touchpad | cut -f2 | cut -d'=' -f2)
    local driver
    [ "$touchpad" ] &&
        driver=$(xinput list-props $touchpad | awk '{if(NR==8) print $1}')

    if [ $($gget $lhand) = false -o "$1" = yes ]; then 
        ##### for gnome
        $gset $batcent false
        $gset $lhand true

        ##### for other wm, if we are in gnome, stop
        #xmodmap -e "pointer = 3 2 1" 2> /dev/null
        # or
        # xinput set-button-map $mouseid 3 2 1
        # although, we probably don't want to use xinput because it's high
        # level and device oriented which means we have to setup for each
        #
        ## for touchbuttons
        case "$driver" in
            libinput)
                # seems libinput don't have "TapButtonX" options
                # but libinput has "LeftHanded" option which only affects to mouse
                # buttons, we can do some trick with this
                xinput set-prop $touchpad 'libinput Tapping Enabled' 1
                xinput set-prop $touchpad 'libinput Left Handed Enabled' 1
                ;;
            Synaptics)
                xmodmap -e "pointer = 3 2 1" 2> /dev/null
                # we can map tapbutton and mousebutton seperately using synclient
                # for tap buttons
                synclient TapButton1=3 TapButton2=1 TapButton3=2
                ;;
        esac
    else
        $gset $batcent true
        $gset $lhand false

        ##### for other wm, if we are in gnome, stop
        xmodmap -e "pointer = default"
        case "$driver" in
            libinput)
                xinput set-prop $touchpad 'libinput Left Handed Enabled' 0
                ;;
            Synaptics)
                synclient TapButton1=1 TapButton2=3 TapButton3=2
                ;;
        esac
    fi
}

lhand(){
    local lhanded
    [ "$mouse" ] && lhanded=$(xinput list-props "$mouse" | grep  "Left Handed Enabled (" | cut -f3)
    [ "$touchpad" ] && lhanded=$(xinput list-props "$touchpad" | grep  "Left Handed Enabled (" | cut -f3)

    if [ "$lhanded" -eq 0 ]; then
        [ "$mouse" ] && xinput set-prop "$mouse" 'libinput Left Handed Enabled' 1
        [ "$touchpad" ] && xinput set-prop "$touchpad" 'libinput Left Handed Enabled' 1
    else
        [ "$mouse" ] && xinput set-prop "$mouse" 'libinput Left Handed Enabled' 0
        [ "$touchpad" ] && xinput set-prop "$touchpad" 'libinput Left Handed Enabled' 0
    fi

    # use the bitwise XOR-equal operator to flip between 0 and 1
    # https://unix.stackexchange.com/a/364489/274163
    echo $((lhanded ^ 1))
}

idlast(){
    #local id=${1::17}
    local id=$1
    [ ${#id} -lt 17 ] && echo 17 numbers, assohole! && return 69
    local factor=(7 9 10 5 8 4 2 1 6 3 7 9 10 5 8 4 2)
    local last=(1 0 X 9 8 7 6 5 4 3 2)

    local i sum=0
    for i in `seq 0 16`
    do
        let sum+=$((${id:$i:1} * ${factor[$i]}))
    done

    echo ${last[$(($sum%11))]}
}

shutthefuckdown(){
    local i pids hour=$(date +%H)
    [ "$1" == -c ] && { pkill -f shutthefuc; return; }
    # 5 minutes countdown.
    for i in $(ls -vr $sound | grep a.mp3)
    do
        $play $sound/$i < /dev/null &> /dev/null &
        if [ ${i:0:2} -eq "60" ]; then
            # push $allrepos to github 60s before shutdown
            for i in $allrepos; do
                cd $i;git add -A;git commit -m "auto commit by dotr";git push
            done &

            sleep 50
        else
            sleep 60
        fi
    done

    # 10 seconds countdown.
    for i in $(ls -vr $sound | grep b.mp3)
    do
        $play $sound/$i < /dev/null &> /dev/null
        sleep 0.1
    done

    $play $sound/bye.mp3

    if [ $hour -eq 12 ]; then
        $play $sound/lunch.mp3 < /dev/null &> /dev/null
    elif [ $hour -eq $offtime ]; then
        $play $sound/night.mp3 < /dev/null &> /dev/null
    fi

    sudo shutdown now
}

# obfuscate file size by compressing with a foo.padding file.
obfus(){
    local ifname=$1 ofname= siz=$2
    read -p "what size you want to obfuscate?" siz
    dd if=/dev/urandom of=$ifname.padding count=$siz

    read -p "output name?" ofname
    tar Jcf $ofname.tar.xz $ifname{.padding,}
}

# encrypt using gpg, put encrypted files into $gpgdir
# take one upto two parameter(s), first is file name, compress before encrypt if $2 is -z
encrypt(){
    local i=$1 j
    # can not be empty, can not be /
    if [ -z "$i" -o "$i" == "/" ];then
        echo "filename not illegal"
    elif [ -e "$i" ]; then
        j=`basename $i`
        # strip "." if it starts the filename
        j=${j#.}

        # compress if file is directory or -z is given
        [ -d $i -o "$2" == "-z" ] && tar Jcf $j.tar.xz $i && j=$j.tar.xz && i=$j && k=$j

        # obfuscate file size if -o is given
        [ "$4" == "-o" ] && obfus $i $5

        gpg -o $gpgdir/$j.gpg --recipient 13538519 -e $i

        # remove temporary file foo.tar.xz after encrypt
        [ -e "$k" ] && rm $k
        # remove file after encrypt if -r is given
        [ "$3" == "-r" ] && rm $1 -rf
    else
        echo  "$i: No such file or directory"
    fi
}

# some backups
backup(){
    local mysqlpass=`gpg -qd $gpgdir/mysqlpasswd.asc`
    local time=`date +%y%m%d_%H%M`
    # start mariadb if not running
    while ! systemctl is-active mariadb &> /dev/null
    do
        sudo systemctl restart mariadb
    done

    # mysql backup
    mysqldump -u root -p$mysqlpass --databases cm > cm.$time.sql
    encrypt cm.$time.sql -z -r
    mv $gpgdir/cm.$time.sql.* $backupdir/mysql

    mysqldump -u root -p$mysqlpass --databases grind > $backupdir/mysql/grind.$time.sql

    find $backupdir/mysql -daystart -mtime +0 -delete

    # backup ~/.ssh/
    encrypt ~/.ssh
    mv $gpgdir/ssh* $backupdir/ssh

    tar Jcf db_ssh_$time.tar.xz $backupdir/{mysql,ssh}
    scp db_ssh_$time.tar.xz $vps:dotbackup && rm db_ssh_$time.tar.xz

    cp /etc/hosts $repoa/conf
    cp /etc/httpd/conf.d/vhosts.conf $repoa/conf/httpd

    # backup $backupdir/

    # backup ~/.local/sound/
}

m(){
    [ $1 ] && { man $@; :; } || man bash
}

ascii_of(){
    if [ "$1" == -c ];then
        [ "$2" -lt 256 ] || return 1
        printf "\\$(printf '%03o' "$2")"
        return 0
    fi
    printf '%d\n' "'$1"
}

v(){
    if [ "$1" ];then
        command vim "$@"
    else
        # $vim_default_file defined in .env
        #command vim $vim_default_file
        # $vim_default_session defined in .env
        command vim -S $vim_default_session
    fi
}

p(){
    mpv --really-quiet "$@" &
}

vim(){
    # sudo looks for external programs, not shell builtins, and not shell functions
    # sudo command vim "$@"
    # sudo $(which vim) "$@"
    sudo vim "$@"
}

d(){
    cd "$@"
}

if [ "$ID" = FreeBSD ]; then
    ll(){
        command ls -l -G "$@"
    }
    l.(){
    command ls -Gd .* "$@"
}
l(){
    command ls -G "$@"
}
ls(){
    # sudo command ls -G "$@"
    # sudo $(which ls) -G "$@"
    sudo ls -G "$@"
}
else
    L(){
        command ls -Z "$@"
    }
    ll(){
        command ls -l --color=auto "$@"
    }
    LL(){
        command ls -lZ "$@"
    }
    l.(){
    command ls -d .* --color=auto "$@"
}
l(){
    command ls --color=auto "$@"
}
ls(){
    # sudo command ls --color=auto "$@"
    # sudo $(which ls) --color=auto "$@"
    sudo ls --color=auto "$@"
}
fi

are_u_sure(){
    read -n1 -p "Are you sure to exit? [y/N] "
    [ "$REPLY" != y ] && { echo; history -a; bash; }
}
#trap are_u_sure EXIT

# reload ~/.{env,fun}
rl(){
    fun_exported=
    env_exported=
    . ~/.env
    . ~/.fun
}

fun_exported=my_length_is_nonzero

[ -f ~/.fun.local ] && . ~/.fun.local

set +a
