#!/bin/bash
# vim:ft=sh
# My functions
# Create hard link ~/.fun when running ~/.ash/a.sh -L
# and ~/.fun will be sourced in ~/.bash_profile
# Export all these funcions and set $FUN_EXPORTED at the end of this file.

# Fedora /etc/bashrc will source /etc/profile.d/*.sh
# and some of them will set aliases
# functions names will be overriden by aliases, this is so sad
# and it causes syntax error if the word is already a alias when define a fun
# So remove all aliases
unalias -a

[ "$FUN_EXPORTED" ] && return # since these functions have been exported, we don't need to soure this file anymore

# use some useless dconf keys to store info is a good idea.

set -a

activate(){
    [ -f .venv/bin/activate ] && . .venv/bin/activate
}

b(){
    # Restore my key sequences if have any argument
    [ $1 ] && { bind -f ~/.inputrc; return; }

    # Otherwise, clear custom key sequences
    local i
    for i in $(bind -S | awk '{print $1}')
    do
        if [ ${#i} -gt 1 ]; then
            if [ $i = '\"' ]; then
                bind '"\"":self-insert'
            else
                bind -r "$i"
            fi
        else
            bind "$i":self-insert
        fi
    done
}

c(){
    cargo "$@"
}

d(){
    cd "$@"
}

e(){
    echo "$@"
}

f(){
    if [ "$1" ]; then
        (feh -. "$@" &)
    fi
}

if [ "$ID" = FreeBSD ]; then
    ll(){
        command ls -l -G "$@"
    }
    # Put l.() { ...; } in one line to avoid vim wrong syntax indentation
    l.(){ command ls -Gd .* "$@"; }
    l(){
        command ls -G "$@"
    }
    ls(){
        # sudo command ls -G "$@"
        # sudo $(which ls) -G "$@"
        sudo ls -G "$@"
    }
else
    L(){
        command ls -Z "$@"
    }
    ll(){
        command ls -l --color=auto "$@"
    }
    LL(){
        command ls -lZ "$@"
    }
    l.(){ command ls -d .* --color=auto "$@"; }
    l(){
        command ls --color=auto "$@"
    }
    ls(){
        # sudo command ls --color=auto "$@"
        # sudo $(which ls) --color=auto "$@"
        sudo ls --color=auto "$@"
    }
fi

m(){
    [ $1 ] && { man $@; :; } || man bash
}

py(){
    python3 "$@"
}

wg(){
    sudo wg "$@"
}

dockertag(){
    [ "$1" ] || return
    wget -q https://registry.hub.docker.com/v1/repositories/$1/tags -O -  | sed -e 's/[][]//g' -e 's/"//g' -e 's/ //g' | tr '}' '\n'  | awk -F: '{print $3}' | less
}

vim(){
    # sudo looks for external programs, not shell builtins, and not shell functions
    # sudo command vim "$@"
    # sudo $(which vim) "$@"
    sudo vim "$@"
}

qr(){
    qrencode -t ansiutf8 "$@"
}

pvz(){
    local p=/.wine/drive_c/Program\ Files/Plants\ vs\ Zombies/PlantsVsZombies.exe
    wine ~/.wine/drive_c/Program\ Files/Plants\ vs\ Zombies/PlantsVsZombies.exe -changedir &> /dev/null &
}

mouse_speed_by_ctm(){
    local ctm
    ctm="Coordinate Transformation Matrix"
    # xinput set-prop 8 156 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000
    # id may change, use name instead
    local x y z
    if is_num $1 && [ "$MOUSE" -a "$ctm" ]; then
        x=$1 y=$1 z=$1
        xinput set-prop "$MOUSE" "$ctm" $x, 0, 0, 0, $y, 0, 0, 0, $z
    fi
}

cmdnotfound(){
    # if last command return 127 (not found), do something with it
    # TODO how to deal with HISTCONTROL ignored command which don't have history?
    local cmd r=$?	# r=$? must at the first line or we'll get return code of `local' builtin
    if [ "$r" -eq 127 ]; then
        cmd=$(HISTTIMEFORMAT= history 1 | sed 's/^ *[0-9]\+ *//')
        # who_is her? OR Who is her?
        tts "${cmd//_/ }"
    fi
}

self_signed_cert(){
    local n
    n=nick
    openssl req -nodes -newkey rsa:4096 -keyout $n.key -x509 -days 3650 -out $n.cer
    cat $n.cer $n.key $n.pem
    #or
    #openssl req -nodes -x509 -newkey rsa:4096 -sha256 -days 3650 -out $n.pem -keyout $n.pem
}

grep(){
    command grep --color=auto "$@"
}

githooks(){
    # Run in root of working tree
    # then hooks in .githooks/ will be tracked and can be triggered whether or not "during a push",
    # as long as it's not a bare repo.
    if [ -d .git ]; then
        mkdir -p .githooks
        ln -sf ../.githooks .git/
        echo Created .githooks/ and symlinked .git/.githooks to it
        echo Don\'t forget to run me on remote if you need to trigger push hooks.
    else
        echo Not a git dir
    fi
}

gen_ssh_keys_for_new_workstation() {
    local user not_copy_list station name
    user=$(id -un)
    not_copy_list='github gitlab drupal'

    if [ "$1" ]; then
        station=$1
    else
        cat << EOF
Usage:
Generate hosts ssh keys for new workstation. It will generate all remote hosts keys that current workstation have access.
$FUNCNAME <new_workstation>
EOF
return
    fi

    if [ -z "$DOMAIN" ]; then
        echo env DOMAIN not set.
        return
    fi

    for name in $(grep -o "\w*\.$DOMAIN" ~/.ssh/config)
    do
        i=${name%%.*}

        ssh-keygen -t ed25519 -f $i -C $user@$station -N ''

        scp $i $user@$station.$DOMAIN:.ssh/ && rm $i

        if [[ ! "$not_copy_list" =~ "$i" ]]; then
            ssh-copy-id -f -i $i.pub $i.$DOMAIN && rm $i.pub
        fi
    done

    scp ~/.ssh/config $user@$station.$DOMAIN:.ssh/
}

expecting_SSH2_MSG_KEX_ECDH_REPLY(){
    local if
    if=$1
    # https://serverfault.com/a/670081
    sudo ip li set mtu 1200 dev $if
}

are_u_sure(){
    read -n1 -p "Are you sure to exit? [y/N] "
    [ "$REPLY" != y ] && { echo; history -a; bash; }
}
#trap are_u_sure EXIT

# reload ~/.{env,fun}
rl(){
    FUN_EXPORTED=
    ENV_EXPORTED=
    . ~/.env
    . ~/.fun
}

let FUN_EXPORTED++

[ -f ~/.fun.local ] && . ~/.fun.local

set +a
